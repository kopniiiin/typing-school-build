'use strict';

const ELEMENT_SELECTOR = '.simulator';
const METERS_SELECTOR = '.simulator__meters';
const CHAR_CONTAINER_SELECTOR = '.simulator__char-container';
const PAUSE_BUTTON_SELECTOR = '.simulator__pause-button';
const HIDDEN_METERS_CLASS = 'simulator__meters_hidden';
const SIMULATOR_WITHOUT_KEYBOARD_CLASS = 'simulator_no-keyboard';
const START_MESSAGE = 'Располагай руки на начальной позиции и жми пробел, чтобы начать';
const START_KEY = ' ';
const REQUIRED_CHARS = /^[а-яА-ЯёЁ0-9 .,:;!?()"_\-+=%№]$/;
const SHIFT_KEY = 'Shift';
const LEFT_SHIFT_CODE = 'ShiftLeft';
const BACKSPACE_KEY = 'Backspace';
const YO_CHAR = 'ё';
const E_CHAR = 'е';
const FOREIGN_CHARS = /^[a-zA-Z]$/;
const FOREIGN_KEYBOARD_MESSAGE = 'Выбери русскую раскладку';
const KEYBOARD_WITHOUT_YO_MESSAGE = 'Выбери раскладку с клавишей Ё';
const TIME_TO_SWITCH_BOXES = 440;
const CHAR_CONTAINER_SWITCH_CLASS = 'simulator__char-container_switch';

class Simulator {
  constructor (parameters) {
    this._element = document.querySelector(ELEMENT_SELECTOR);
    this._meters = this._element.querySelector(METERS_SELECTOR);
    this._charContainer = this._element.querySelector(CHAR_CONTAINER_SELECTOR);

    this._pauseButton = this._element.querySelector(PAUSE_BUTTON_SELECTOR);
    this._pauseButton.addEventListener('click', this._pauseButtonClickHandler);

    this._isTypoOccured = false;

    this._isForeignKeyboardSelected = false;
    this._isYoOnKeyboardWithoutYoTyped = false;

    this._isStarted = false;
    this._isPaused = false;
    this._pauseDuaration = 0;

    this._pressedKeys = new Set();

    this._accuracyMeter = new AccuracyMeter();
    this._speedometer = new Speedometer();

    this._textBox = new TextBox(parameters.textBoxTexts);
    this._charContainer.appendChild(this._textBox.element);

    this._hintLine = new HintLine();
    this._hintDialog = new HintDialog();

    this._keyboard = new Keyboard(parameters.keyboardType, parameters.areHandsOn);
    this._keyboardSelectDialog = new KeyboardSelectDialog(this._keyboard);

    if (!parameters.isKeyboardOn) {
      this.toggleKeyboard();
    }

    this._pauseDialog = new PauseDialog(
      this,
      this._keyboard,
      this._keyboardSelectDialog,
    );

    this._statistics = new Statistics(parameters.problemKeyCodes);

    this._setupKeyboard()
      .then(() => this._showHintDialogMessage(parameters.hintDialogMessage))
      .then(() => {
        this._hintLine.showHintMessage(START_MESSAGE);
        this._keyboard.showHowToType(START_KEY);
        return this._waitForUserStartKeyKeyup();
      })
      .then(() => {
        this._hintLine.hideMessage();
        this._start();
      });
  }

  toggleKeyboard () {
    this._element.classList.toggle(SIMULATOR_WITHOUT_KEYBOARD_CLASS);
  }

  get isKeyboardOn () {
    return !this._element.classList.contains(SIMULATOR_WITHOUT_KEYBOARD_CLASS);
  }

  async _setupKeyboard () {
    if (this._keyboard.type) return;

    return this._keyboardSelectDialog.open(true);
  }

  async _showHintDialogMessage (hintDialogMessage) {
    if (!hintDialogMessage) return;

    return this._hintDialog.showHintMessage(hintDialogMessage);
  }

  _start () {
    this._isStarted = true;
    this._startTime = Date.now();

    document.addEventListener('keydown', this._keydownHandler);
    window.addEventListener('keyup', this._keyupHandler);

    if (this._isTimeToTypeKeys) {
      this._startWithKeys();
    } else {
      this._startWithText();
    }
  }

  _waitForUserStartKeyKeyup () {
    return new Promise((resolve) => {
      const startKeyKeyupHandler = (evt) => {
        // Во время паузы нажатия стартовой клавиши не учитываются
        if (
          evt.key !== START_KEY ||
          this._isPaused
        ) return;

        document.removeEventListener('keyup', startKeyKeyupHandler);
        resolve();
      };

      document.addEventListener('keyup', startKeyKeyupHandler);
    });
  }

  _startWithKeys () {
    this._keyBox.showCursor();
    this._keyboard.showHowToType(this._keyBox.requiredChar);
  }

  _startWithText () {
    this._meters.classList.remove(HIDDEN_METERS_CLASS);
    this._textBox.showCursor();
    this._keyboard.showHowToType(this._textBox.requiredChar);
    this._speedometer.start();
  }

  _pause() {
    this._isPaused = true;

    document.removeEventListener('keydown', this._keydownHandler);

    // До старта урока после паузы ничего дополнительного делать не нужно
    if (!this._isStarted) {
      this._pauseDialog.open()
        .then(() => this._isPaused = false);

      return;
    }

    this._pauseTime = Date.now();

    if (!this._isTimeToTypeKeys) {
      this._speedometer.pause();
    }

    this._pauseDialog.open()
      .then(() => {
        this._isPaused = false;
        this._hintLine.showHintMessage(START_MESSAGE);
        return this._waitForUserStartKeyKeyup();
      }).then(() => {
        this._hintLine.hideMessage();
        this._continue();
      });
  }

  _continue () {
    this._pauseDuaration += Date.now() - this._pauseTime;

    document.addEventListener('keydown', this._keydownHandler);

    if (!this._isTimeToTypeKeys) {
      this._speedometer.continue();
    }
  }

  _pauseButtonClickHandler = () => {
    this._pause();
  };

  _keydownHandler = (evt) => {
    if (
      evt.ctrlKey || evt.altKey || evt.metaKey ||
      this._pressedKeys.has(evt.code)
    ) return;

    const key = evt.key;

    if (FOREIGN_CHARS.test(key)) {
      this._hintLine.showWarningMessage(FOREIGN_KEYBOARD_MESSAGE);
      this._isForeignKeyboardSelected = true;
      return;
    }

    if (this._isForeignKeyboardSelected) {
      this._hintLine.hideMessage();
      this._isForeignKeyboardSelected = false;
    }

    if (!this._keyboard.hasYo && key.toLowerCase() === YO_CHAR) {
      this._hintLine.showWarningMessage(KEYBOARD_WITHOUT_YO_MESSAGE);
      this._isYoOnKeyboardWithoutYoTyped = true;
      return;
    }

    if (this._isYoOnKeyboardWithoutYoTyped) {
      this._hintLine.hideMessage();
      this._isYoOnKeyboardWithoutYoTyped = false;
    }

    this._pressedKeys.add(evt.code);

    if (REQUIRED_CHARS.test(key)) {
      this._handleCharKeyKeydown(evt);
      return;
    }

    if (key === SHIFT_KEY) {
      this._handleShiftKeyKeydown(evt);
      return;
    }

    if (key === BACKSPACE_KEY) {
      this._handleBackspaceKeyKeydown();
    }
  };

  _handleCharKeyKeydown (evt) {
    const typedChar = evt.key;

    this._keyboard.pressCharKey(typedChar);

    if (this._isTypoOccured) return;

    if (this._isTimeToTypeKeys) {
      this._handleKeyTyping(typedChar);
    } else {
      this._handleTextTyping(evt);
    }
  }

  _handleShiftKeyKeydown(evt) {
    this._keyboard.pressShiftKey(evt.code === LEFT_SHIFT_CODE);
  }

  _handleBackspaceKeyKeydown() {
    this._keyboard.pressBackspaceKey();

    if (!this._isTypoOccured) return;

    if (this._isTimeToTypeKeys) {
      this._handleKeyErasing();
    } else {
      this._handleTextErasing();
    }
  }

  _handleKeyTyping(typedChar) {
    typedChar = this._transformTypedCharIfNeeded(typedChar, this._keyBox.requiredChar);

    if (!this._keyBox.type(typedChar)) {
      this._isTypoOccured = true;
      this._keyboard.showHowToErase();
      return;
    }

    if (this._keyBox.isFull) {
      this._switchBoxes();
      return;
    }

    this._keyboard.showHowToType(this._keyBox.requiredChar);
  }

  _handleTextTyping(evt) {
    const typedChar = this._transformTypedCharIfNeeded(evt.key, this._textBox.requiredChar);

    if (!this._textBox.type(typedChar)) {
      this._isTypoOccured = true;
      this._accuracyMeter.addTypo();
      this._keyboard.showHowToErase();
      this._statistics.addWrongKeyCode(evt.code);
      return;
    }

    this._statistics.addCorrectKeyCode(evt.code);
    this._accuracyMeter.addCorrectChar();
    this._speedometer.addChar();

    if (this._textBox.isFull) {
      this._finish();
      return;
    }

    if (this._textBox.isTimeToScroll) {
      this._textBox.scroll();
    }

    this._keyboard.showHowToType(this._textBox.requiredChar);
  }

  _transformTypedCharIfNeeded (typedChar, requiredChar) {
    if (
      this._keyboard.hasYo || 
      typedChar.toLowerCase() !== E_CHAR ||
      requiredChar.toLowerCase() !== YO_CHAR
    ) return typedChar;

    if (typedChar === E_CHAR) return YO_CHAR;
    if (typedChar === E_CHAR.toUpperCase()) return YO_CHAR.toUpperCase();
  }

  _handleKeyErasing() {
    this._isTypoOccured = false;

    this._keyBox.erase();

    this._keyboard.showHowToType(this._keyBox.requiredChar);
  }

  _handleTextErasing() {
    this._isTypoOccured = false;

    this._textBox.erase();

    this._keyboard.showHowToType(this._textBox.requiredChar);
  }

  _keyupHandler = (evt) => {
    if (evt.ctrlKey || evt.altKey || evt.metaKey) return;

    const { key, code } = evt;

    if (!this._pressedKeys.has(code)) return;

    this._pressedKeys.delete(code);

    if (REQUIRED_CHARS.test(key)) {
      this._keyboard.releaseCharKey(key);
      return;
    }

    if (key === SHIFT_KEY) {
      this._keyboard.releaseShiftKey(code === LEFT_SHIFT_CODE);
      return;
    }

    if (key === BACKSPACE_KEY) {
      this._keyboard.releaseBackspaceKey();
    }
  };

  _switchBoxes() {
    document.removeEventListener('keydown', this._keydownHandler);

    this._isTimeToTypeKeys = false;

    this._keyboard.takeInitialPosition();

    this._charContainer.classList.add(CHAR_CONTAINER_SWITCH_CLASS);

    setTimeout(() => {
      this._charContainer.replaceChild(this._textBox.element, this._keyBox.element);
      this._charContainer.classList.remove(CHAR_CONTAINER_SWITCH_CLASS);

      this._startWithText();

      document.addEventListener('keydown', this._keydownHandler);
    }, TIME_TO_SWITCH_BOXES);
  }

  _finish () {
    document.removeEventListener('keydown', this._keydownHandler);

    this._keyboard.takeInitialPosition();
    this._speedometer.finish();

    const keyCodesToTypoAmounts = {};
    this._statistics.keyCodesToTypoAmounts.forEach((typoAmount, keyCode) => {
      keyCodesToTypoAmounts[keyCode] = typoAmount;
    });

    const keyCodesToCorrectSeriesAmounts = {};
    this._statistics.keyCodesToCorrectSeriesAmounts.forEach((correctSeriesAmount, keyCode) => {
      keyCodesToCorrectSeriesAmounts[keyCode] = correctSeriesAmount;
    });

    const lessonResults = {
      lessonDuration: Date.now() - this._startTime - this._pauseDuaration,
      lessonLength: this._keyBox ?
          this._keyBox.length + this._textBox.length : this._textBox.length,
      averageSpeed: this._speedometer.averageSpeed,
      keyCodesToTypoAmounts: keyCodesToTypoAmounts,
      keyCodesToCorrectSeriesAmounts: keyCodesToCorrectSeriesAmounts
    };
  }
}

const TIME_BETWEEN_CALCULATIONS = 1000;
const SECONDS_PER_PERIOD_LIMIT = 10;
const SECONDS_PER_MINUTE = 60;
const MILLISECONDS_PER_MINUTE = 60000;

class Speedometer {
  constructor() {
    this._element = document.querySelector('.speedometer');
    this._indicator = this._element.querySelector('.speedometer__indicator');

    this._charCounters = [];
    this._currentCharCounter = 0;
    this._currentSpeed = 0;

    // Для правильного продолжения работы после паузы состояние сохраняется
    // после каждого нажатия и в начале работы
    this._saveCurrentState();

    this._totalCharCounter = 0;

    this._pauseDuration = 0;
  }

  start() {
    this._startTime = Date.now();
    
    this._calculationInterval = setInterval(
      this._speedCalculator, 
      TIME_BETWEEN_CALCULATIONS
    );
  }

  pause() {
    clearInterval(this._calculationInterval);
    
    this._pauseTime = Date.now();
  }

  continue() {
    this._restoreCurrentState();

    this._pauseDuration += Date.now() - this._pauseTime;
    
    this._calculationInterval = setInterval(
      this._speedCalculator, 
      TIME_BETWEEN_CALCULATIONS
    );
  }

  finish() {
    clearInterval(this._calculationInterval);
    
    this._calculateAverageSpeed();
  }

  addChar() {
    this._totalCharCounter++;
    this._currentCharCounter++;

    this._saveCurrentState();
  }

  get averageSpeed () {
    return this._averageSpeed;
  }

  _speedCalculator = () => {
    this._charCounters.push(this._currentCharCounter);
    this._currentCharCounter = 0;

    const charsPerPeriod = this._charCounters.reduce((charsPerPeriod, charsPerSecond) =>
      charsPerPeriod + charsPerSecond
    );

    const secondsPerPeriod = this._charCounters.length;

    // Скорость измеряется в сим/мин
    this._currentSpeed = Math.round(
      charsPerPeriod * (SECONDS_PER_MINUTE / secondsPerPeriod)
    );

    this._updateIndicator();

    if (secondsPerPeriod === SECONDS_PER_PERIOD_LIMIT) {
      this._charCounters.shift();
    }
  };

  _calculateAverageSpeed() {
    const totalTimeInMilliseconds = Date.now() - this._startTime - this._pauseDuration;
    const totalTimeInMinutes = totalTimeInMilliseconds / MILLISECONDS_PER_MINUTE;

    // Скорость измеряется в сим/мин
    this._averageSpeed = Math.round(
      this._totalCharCounter / totalTimeInMinutes
    );
  }

  _updateIndicator() {
    this._indicator.textContent = this._currentSpeed;
  }

  _saveCurrentState() {
    this._lastCharCounters = this._charCounters.slice();
    this._lastCharCounter = this._currentCharCounter;
    this._lastSpeed = this._currentSpeed;
  }

  _restoreCurrentState() {
    this._charCounters = this._lastCharCounters.slice();
    this._currentCharCounter = this._lastCharCounter;
    this._currentSpeed = this._lastSpeed;

    this._updateIndicator();
  }
}

class AccuracyMeter {
  constructor() {
    this._element = document.querySelector('.accuracy-meter');
    this._indicator = this._element.querySelector('.accuracy-meter__indicator');

    this._totalCharCounter = 0;
    this._correctCharCounter = 0;
  }

  addCorrectChar() {
    this._totalCharCounter++;
    this._correctCharCounter++;
    this._calculateAccuracy();
    this._updateIndicator();
  }

  addTypo() {
    this._totalCharCounter++;
    this._calculateAccuracy();
    this._updateIndicator();
  }

  get accuracy() {
    return this._accuracy;
  }

  _calculateAccuracy() {
    this._accuracy = Math.round((this._correctCharCounter / this._totalCharCounter) * 100);
  }

  _updateIndicator() {
    this._indicator.textContent = this._accuracy + '%';
  }
}

class TextChar {
  constructor (requiredChar) {
    this._element = TextChar.template.cloneNode(true);
    
    this._requiredChar = requiredChar;

    this._element.textContent = this._requiredChar;
  }

  type (typedChar) {
    this._typedChar = typedChar;
    
    const isTypedCharCorrect = this._typedChar === this._requiredChar;

    if (isTypedCharCorrect) {
      this._element.classList.add('text-char_correct');
    } else {
      this._element.classList.add('text-char_typo');
      this._element.textContent = this._typedChar;
    }

    this.hideCursor();

    return isTypedCharCorrect;
  }

  erase () {
    const isTypoErased = this._typedChar !== this._requiredChar;

    this._element.classList.remove('text-char_correct', 'text-char_typo');
    this._element.textContent = this._requiredChar;

    this._typedChar = null;

    this.showCursor();

    return isTypoErased;
  }

  showCursor () {
    this._element.classList.add('text-char_cursor');
  }

  hideCursor () {
    this._element.classList.remove('text-char_cursor');
  }

  get element () {
    return this._element;
  }

  get requiredChar () {
    return this._requiredChar;
  }

  get isFull () {
    return Boolean(this._typedChar)
  }
}

TextChar.template = document.querySelector('#template-text-char')
  .content.querySelector('.text-char');

class TextLine {
  constructor(text) {
    this._element = TextLine.template.cloneNode(true);

    this._chars = [];

    text.split('').forEach(char => {
      const newChar = new TextChar(char);

      this._chars.push(newChar);
      
      this._element.appendChild(newChar.element);
    });

    this._currentCharIndex = 0;
    this._currentChar = this._chars[this._currentCharIndex];
  }

  type (typedChar) {
    const isTypedCharCorrect = this._currentChar.type(typedChar);

    if (!this.isFull) {
      this._moveCurrentCharForward();
    }

    return isTypedCharCorrect;
  }

  erase () {
    // Если строка полная, то стирается последний символ
    if (!this.isFull) {
      this._moveCurrentCharBackward();
    }

    return this._currentChar.erase();
  }

  showCursor () {
    this._currentChar.showCursor();
  }

  hideCursor () {
    this._currentChar.hideCursor();
  }

  get element () {
    return this._element;
  }

  get requiredChar () {
    return this._currentChar.requiredChar;
  }

  get isEmpty () {
    return !this._currentChar.isFull &&
      this._currentCharIndex === 0;
  }

  get isFull () {
    return this._currentChar.isFull &&
      this._currentCharIndex === this._chars.length - 1;
  }

  get length () {
    return this._chars.length;
  }

  _moveCurrentCharForward () {
    this._currentCharIndex++;
    this._currentChar = this._chars[this._currentCharIndex];
    this._currentChar.showCursor();
  }

  _moveCurrentCharBackward () {
    this._currentChar.hideCursor();
    this._currentCharIndex--;
    this._currentChar = this._chars[this._currentCharIndex];
  }
}

TextLine.template = document.querySelector('#template-text-line')
  .content.querySelector('.text-line');

class TextBox {  
  constructor (texts) {
    this._element = TextBox.template.cloneNode(true);
    
    this._lines = [];
    
    texts.forEach(text => {
      const newLine = new TextLine(text);
      
      this._lines.push(newLine);
      
      newLine.element.classList.add('text-box__text-line');
      this._element.appendChild(newLine.element);
    });

    this._currentLineIndex = 0;
    this._currentLine = this._lines[this._currentLineIndex];

    this._scrollHeight = 0;
  }

  type (typedChar) {
    const isTypedCharCorrect = this._currentLine.type(typedChar);

    if (!this.isFull && this._currentLine.isFull) {
        this._moveCurrentLineForward();
    }

    return isTypedCharCorrect;
  }

  erase () {
    if (this._currentLine.isEmpty) {
      this._moveCurrentLineBackward();
    }

    return this._currentLine.erase();
  }

  showCursor () {
    this._currentLine.showCursor();
  }

  hideCursor () {
    this._currentLine.hideCursor();
  }

  scroll () {
    this._scrollHeight++;

    this._lines.forEach(line => {
      line.element.style.transform = `translateY(${this._scrollHeight * -100}%)`;
    });
  }

  get element () {
    return this._element;
  }

  get requiredChar () {
    return this._currentLine.requiredChar;
  }

  get isEmpty () {
    return this._currentLineIndex === 0 &&
        this._currentLine.isEmpty;
  }

  get isFull () {
    return this._currentLineIndex === this._lines.length - 1 &&
        this._currentLine.isFull;
  }

  get isTimeToScroll () {
    return this._currentLine.isEmpty &&
      this._currentLineIndex > 1 &&
      this._currentLineIndex < this._lines.length - 1;
  }

  get length () {
    return this._lines.reduce((boxLength, lineLength) => {
      return boxLength + lineLength.length;
    }, 0);
  }

  _moveCurrentLineForward () {
    this._currentLineIndex++;
    this._currentLine = this._lines[this._currentLineIndex];
    this._currentLine.showCursor();
  }

  _moveCurrentLineBackward () {
    this._currentLine.hideCursor();
    this._currentLineIndex--;
    this._currentLine = this._lines[this._currentLineIndex];
  }
}

TextBox.template = document.querySelector('#template-text-box')
  .content.querySelector('.text-box');


class HintLine {
  constructor () {
    this._element = document.querySelector('.hint-line');
  }

  showHintMessage (hintMessage) {
    this._element.textContent = hintMessage;
    this._element.classList.remove('hint-line_hidden', 'hint-line_warning');
  }

  showWarningMessage (warningMessage) {
    this._element.textContent = warningMessage;
    this._element.classList.add('hint-line_warning')
    this._element.classList.remove('hint-line_hidden');
  }

  hideMessage () {
    this._element.classList.add('hint-line_hidden');
  }
}

const DEFAULT_KEYBOARD_TYPE = 'keyboard-windows-ansi-rus-pc';

const KEYBOARD_TYPE_WITHOUT_YO = 'keyboard-macos-ansi-rus-pc';

const HAND_INITIAL_POSITION = 1;

const LEFT_HAND_POSITIONS_TO_OFFSETS = [
  {x: 0, y: 0},
  {x: -15, y: -22},
  {x: -18, y: -22},
  {x: -18, y: -21},
  {x: -20, y: -21},
  {x: -21, y: -23},
  {x: -21, y: -21},
  {x: -21, y: -20},
  {x: -1, y: -9},
  {x: -1, y: -11},
  {x: -1, y: -12},
  {x: -3, y: -11},
  {x: 0, y: -10},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: -8, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: -2, y: -2},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0}
];

const RIGHT_HAND_POSITIONS_TO_OFFSETS = [
  {x: 0, y: 0},
  {x: 4, y: -22},
  {x: 1, y: -21},
  {x: 2, y: -23},
  {x: 2, y: -22},
  {x: 2, y: -24},
  {x: 3, y: -25},
  {x: 4, y: -20},
  {x: 4, y: -8},
  {x: 1, y: -9},
  {x: 0, y: -10},
  {x: 0, y: -9},
  {x: 0, y: -10},
  {x: 1, y: -12},
  {x: 0, y: -11},
  {x: -4, y: -9},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 1, y: 0},
  {x: 0, y: 0},
  {x: 1, y: -5},
  {x: 0, y: 0},
  {x: 0, y: 0},
  {x: 0, y: 1},
  {x: 0, y: 0},
];

class Keyboard {
  constructor (keyboardType, areHandsOn) {
    this._element = document.querySelector('.keyboard');
    this._keys = this._element.querySelector('.keyboard__keys');
    this._leftHand = this._element.querySelector('.keyboard__hand_left');
    this._rightHand = this._element.querySelector('.keyboard__hand_right');

    this._isHandToPressSpaceKeyLeft = true;
    this._isTimeToPressBackspace = false;

    this._keyboardType = keyboardType;

    if (!this._keyboardType) return;

    if (this._keyboardType !== DEFAULT_KEYBOARD_TYPE) {
      this._replaceKeys();
    }

    this._rememberHowToPressKeys();

    if (!areHandsOn) {
      this.toggleHands();
    }
  }

  showHowToType (requiredChar) {
    this._hideCurrentRequiredKeys();

    this._requiredChar = requiredChar;

    requiredChar = this._transformCharIfNeeded(requiredChar);

    const requiredCharKeyPressingInfo = this._charsToPressingInfo.get(requiredChar);
    
    this._showRequiredKeys(
      requiredCharKeyPressingInfo.charKey, 
      requiredCharKeyPressingInfo.shiftKey
    );

    let leftHandPosition = requiredCharKeyPressingInfo.leftHandPosition;
    let rightHandPosition = requiredCharKeyPressingInfo.rightHandPosition;

    // После нажатия любой символьной клашивши (отличной от пробела) пробел нажимается рукой,
    // которая была в начальном положении или нажимала shift.
    // Пробелы подряд нажимаются одной рукой.
    if (this._requiredChar === ' ') {
      leftHandPosition = this._isHandToPressSpaceKeyLeft ? leftHandPosition : HAND_INITIAL_POSITION;
      rightHandPosition = this._isHandToPressSpaceKeyLeft ? HAND_INITIAL_POSITION : rightHandPosition;
    } else {
      this._isHandToPressSpaceKeyLeft =
        leftHandPosition === HAND_INITIAL_POSITION ||
        leftHandPosition === this._leftShiftKeyPressingInfo.leftHandPosition;
    }

    this._showHandPosition(leftHandPosition, rightHandPosition);
  }

  showHowToErase () {
    this._hideCurrentRequiredKeys();

    this._isTimeToPressBackspace = true;

    this._showRequiredKeys(this._backspaceKeyPressingInfo.backspaceKey);

    this._showHandPosition(this._backspaceKeyPressingInfo.leftHandPosition, this._backspaceKeyPressingInfo.rightHandPosition);
  }

  takeInitialPosition () {
    this._hideCurrentRequiredKeys();
    this._showHandPosition(HAND_INITIAL_POSITION, HAND_INITIAL_POSITION);
  }

  pressCharKey (typedChar) {
    this._showPressedKey(this._charsToPressingInfo.get(typedChar).charKey);
  }

  releaseCharKey (typedChar) {
    this._hideReleasedKey(this._charsToPressingInfo.get(typedChar).charKey);
  }

  pressShiftKey (isLeft) {
    const pressedShiftKey = isLeft ?
      this._leftShiftKeyPressingInfo.shiftKey :
      this._rightShiftKeyPressingInfo.shiftKey;

    this._showPressedKey(pressedShiftKey);
  }

  releaseShiftKey (isLeft) {
    const releasedShiftKey = isLeft ?
      this._leftShiftKeyPressingInfo.shiftKey :
      this._rightShiftKeyPressingInfo.shiftKey;

    this._hideReleasedKey(releasedShiftKey);
  }

  pressBackspaceKey () {
    this._showPressedKey(this._backspaceKeyPressingInfo.backspaceKey);
  }

  releaseBackspaceKey () {
    this._hideReleasedKey(this._backspaceKeyPressingInfo.backspaceKey);
  }

  toggleHands () {
    this._element.classList.toggle('keyboard_no-hands');
  }

  changeType (keyboardType) {
    this._keyboardType = keyboardType;

    this._isHandToPressSpaceKeyLeft = true;

    this._replaceKeys();
    this._rememberHowToPressKeys();

    if (this._requiredChar) {
      this.showHowToType(this._requiredChar);
    } else if (this._isTimeToPressBackspace) {
      this.showHowToErase();
    }
  }

  get type () {
    return this._keyboardType;
  }

  get areHandsOn () {
    return !this._element.classList.contains('keyboard_no-hands');
  }

  get hasYo () {
    return this._keyboardType !== KEYBOARD_TYPE_WITHOUT_YO;
  }

  _showPressedKey (pressedKey) {
    const pressedKeyClass = (pressedKey.classList.contains('keyboard__key_required')) ?
      'keyboard__key_correct' :
      'keyboard__key_wrong';

    pressedKey.classList.add(pressedKeyClass);
  }

  _hideReleasedKey (releasedKey) {
    releasedKey.classList.remove('keyboard__key_correct', 'keyboard__key_wrong');
  }

  _showRequiredKeys (firstRequiredKey, secondRequiredKey) {
    firstRequiredKey.classList.add('keyboard__key_required');

    if (!secondRequiredKey) return;

    secondRequiredKey.classList.add('keyboard__key_required');
  }

  _showHandPosition (leftHandPosition, rightHandPosition) {
    const leftHandOffsetX = LEFT_HAND_POSITIONS_TO_OFFSETS[leftHandPosition - 1].x;
    const leftHandOffsetY = LEFT_HAND_POSITIONS_TO_OFFSETS[leftHandPosition - 1].y;
    this._leftHand.innerHTML = `<use xlink:href='#hand-left-${leftHandPosition}'></use>`;
    this._leftHand.style.transform = `translate(${leftHandOffsetX}%, ${leftHandOffsetY}%)`;

    const rightHandOffsetX = RIGHT_HAND_POSITIONS_TO_OFFSETS[rightHandPosition - 1].x;
    const rightHandOffsetY = RIGHT_HAND_POSITIONS_TO_OFFSETS[rightHandPosition - 1].y;
    this._rightHand.innerHTML = `<use xlink:href='#hand-right-${rightHandPosition}'></use>`;
    this._rightHand.style.transform = `translate(${rightHandOffsetX}%, ${rightHandOffsetY}%)`;
  }

  _hideCurrentRequiredKeys () {
    this._leftShiftKeyPressingInfo.shiftKey.classList.remove('keyboard__key_required');
    this._rightShiftKeyPressingInfo.shiftKey.classList.remove('keyboard__key_required');

    this._isTimeToPressBackspace = false;
    this._backspaceKeyPressingInfo.backspaceKey.classList.remove('keyboard__key_required');

    if (!this._requiredChar) return;

    const charToFindRequiredCharKey = this._transformCharIfNeeded(this._requiredChar);

    this._charsToPressingInfo.get(charToFindRequiredCharKey).charKey
      .classList.remove('keyboard__key_required');

    this._requiredChar = null;
  }

  _transformCharIfNeeded (char) {
    if (
      this.hasYo ||
      char.toLowerCase() !== 'ё'
    ) return char;

    if (char === 'ё') return 'е';
    if (char === 'ё'.toUpperCase()) return 'е'.toUpperCase();
  }

  _replaceKeys () {
    const newReplaceableKeys = Keyboard.template.getElementById(this._keyboardType).cloneNode(true);
    const oldReplaceableKeys = this._keys.querySelector('.keyboard__replaceable-keys');

    this._keys.replaceChild(newReplaceableKeys, oldReplaceableKeys);
  }

  _rememberHowToPressKeys () {
    this._rememberHowToPressShiftKeys();
    
    this._rememberHowToPressBackspaceKey();

    this._charsToPressingInfo = new Map();

    this._element.querySelectorAll('[data-char]').forEach((charKey) => {
      this._rememberHowToPressCharKey(charKey);
    });
  }

  _rememberHowToPressShiftKeys () {
    const leftShiftKey = this._element.querySelector('[data-shift="left"]');
    const rightShiftKey = this._element.querySelector('[data-shift="right"]');

    this._leftShiftKeyPressingInfo = {
      shiftKey: leftShiftKey,
      leftHandPosition: parseInt(leftShiftKey.dataset.leftHandPosition)
    };

    this._rightShiftKeyPressingInfo = {
      shiftKey: rightShiftKey,
      rightHandPosition: parseInt(rightShiftKey.dataset.rightHandPosition)
    };
  }

  _rememberHowToPressBackspaceKey () {
    const backspaceKey = this._element.querySelector('[data-backspace]');

    // клавиша backspace всегда нажимается правой рукой
    this._backspaceKeyPressingInfo = {
      backspaceKey: backspaceKey,
      leftHandPosition: HAND_INITIAL_POSITION,
      rightHandPosition: parseInt(backspaceKey.dataset.rightHandPosition)
    }
  };

  _rememberHowToPressCharKey (charKey) {
    const char = charKey.dataset.char;
    const shiftChar = charKey.dataset.shiftChar;
    const leftHandPosition = parseInt(charKey.dataset.leftHandPosition) || HAND_INITIAL_POSITION;
    const rightHandPosition = parseInt(charKey.dataset.rightHandPosition) || HAND_INITIAL_POSITION;

    this._charsToPressingInfo.set(char, {
      charKey: charKey,
      leftHandPosition: leftHandPosition,
      rightHandPosition: rightHandPosition
    });

    if (!shiftChar) return;

    const isLeftShiftRequired = leftHandPosition === HAND_INITIAL_POSITION;

    this._charsToPressingInfo.set(shiftChar, {
      charKey: charKey,
      shiftKey: isLeftShiftRequired ? this._leftShiftKeyPressingInfo.shiftKey : this._rightShiftKeyPressingInfo.shiftKey,
      leftHandPosition: isLeftShiftRequired ? this._leftShiftKeyPressingInfo.leftHandPosition : leftHandPosition,
      rightHandPosition: isLeftShiftRequired ? rightHandPosition : this._rightShiftKeyPressingInfo.rightHandPosition
    });
  }
}

Keyboard.template = document.querySelector('#template-keyboard').content;

class HintDialog {
  constructor () {
    this._element = document.querySelector('.hint-dialog');
    this._overlay = this._element.querySelector('.hint-dialog__overlay');
    this._message = this._element.querySelector('.hint-dialog__message');
    this._closeButton  = this._element.querySelector('.hint-dialog__close-button');
    
    this._overlay.addEventListener('click', this._overlayClickHandler);
    this._closeButton.addEventListener('click', this._closeButtonClickHandler);
  }

  async showHintMessage (hintMessage) {
    this._element.classList.remove('hint-dialog_hidden');
    this._message.textContent = hintMessage;
    this._closeButton.focus();

    document.addEventListener('keydown', this._keydownHandler);

    return new Promise((resolve => {
      this._closeDialogPromiseResolver = resolve;
    }));
  }

  _close () {
    this._element.classList.add('hint-dialog_hidden');

    document.removeEventListener('keydown', this._keydownHandler);

    this._closeDialogPromiseResolver();
  };

  _manageFocus = () => {
    if (document.activeElement !== this._closeButton) {
      this._closeButton.focus();
    }
  };

  _overlayClickHandler = () => {
    this._close();
  };
  
  _closeButtonClickHandler = () => {
    this._close();  
  };
  
  _keydownHandler = (evt) => {
    if (evt.key === 'Tab') {
      evt.preventDefault();
      this._manageFocus();
    }
    
    if (evt.key === 'Escape') {
      evt.preventDefault();
      this._close();
    }
  };
}

class PauseDialog {  
  constructor(simulator, keyboard, keyboardSelectDialog) {
    this._element = document.querySelector('.pause-dialog');
    this._overlay = this._element.querySelector('.pause-dialog__overlay');
    this._options = this._element.querySelector('.pause-dialog__options');
    
    this._closeButton = this._element.querySelector('.pause-dialog__close-button');
    this._keyboardButton = this._options.querySelector('.pause-dialog__keyboard-button');
    this._submitButton = this._options.querySelector('.pause-dialog__submit-button');

    this._keyboardToggle = new Toggle(
      this._options.querySelector('.pause-dialog__toggle_keyboard')
    );

    this._handsToggle = new Toggle(
      this._options.querySelector('.pause-dialog__toggle_hands')
    );

    this._simulator = simulator;

    this._keyboard = keyboard;

    this._keyboardSelectDialog = keyboardSelectDialog;

    this._overlay.addEventListener('click', this._overlayClickHandler);
    this._closeButton.addEventListener('click', this._closeButtonClickHandler);
    this._keyboardButton.addEventListener('click', this._keyboardButtonClickHandler);
    this._options.addEventListener('click', this._optionsClickHandler);
    this._options.addEventListener('submit', this._optionsSubmitHandler);

    this._initialOptionVariants = {
      isKeyboardOn: this._simulator.isKeyboardOn,
      areHandsOn: this._keyboard.areHandsOn
    };

    this._setInitialOptionVariants();
  }

  open () {
    this._element.classList.remove('pause-dialog_hidden');

    document.addEventListener('keydown', this._keydownHandler);

    this._closeButton.focus();
    
    return new Promise((resolve => {
      this._closeDialogPromiseResolver = resolve;
    }));
  }
  
  _close = () => {
    this._element.classList.add('pause-dialog_hidden');

    document.removeEventListener('keydown', this._keydownHandler);

    this._setInitialOptionVariants();
  
    this._closeDialogPromiseResolver();
  };

  _setInitialOptionVariants () {
    if (this._keyboardToggle.isChecked !== this._initialOptionVariants.isKeyboardOn) {
      this._keyboardToggle.toggle();
    }

    if (this._handsToggle.isChecked !== this._initialOptionVariants.areHandsOn) {
      this._handsToggle.toggle();
    }

    this._manageAbilityToToggleHands();
    this._manageAbilityToSubmitOptions();
  }
  
  _submitOptions () {
    this._initialOptionVariants = {
      isKeyboardOn: this._keyboardToggle.isChecked,
      areHandsOn: this._handsToggle.isChecked
    };

    if (this._initialOptionVariants.isKeyboardOn !== this._simulator.isKeyboardOn) {
      this._simulator.toggleKeyboard();
    }

    if (this._initialOptionVariants.areHandsOn !== this._keyboard.areHandsOn) {
      this._keyboard.toggleHands();
    }

    this._submitButton.disabled = true;
  }
  
  _manageAbilityToSubmitOptions () {
    this._submitButton.disabled = 
      this._keyboardToggle.isChecked === this._initialOptionVariants.isKeyboardOn &&
      this._handsToggle.isChecked === this._initialOptionVariants.areHandsOn;
  }

  _manageAbilityToToggleHands () {
    this._handsToggle.disabled = !this._keyboardToggle.isChecked;
  }

  _manageFocus = (evt) => {
    let lastFocusableElement = this._submitButton.disabled ?
        this._keyboardButton : this._submitButton;

    if (evt.shiftKey) {
      if (document.activeElement === this._closeButton) {
        evt.preventDefault();
        lastFocusableElement.focus();
      }
    } else if (document.activeElement === lastFocusableElement) {
      evt.preventDefault();
      this._closeButton.focus();
    }
  };

  async _openKeyboardSelectDialog () {
    this._element.classList.add('pause-dialog_hidden');

    document.removeEventListener('keydown', this._keydownHandler);

    await this._keyboardSelectDialog.open();

    this._keyboardButton.textContent = this._keyboardSelectDialog.keyboardLayout;
    this._keyboardButton.focus();

    this._element.classList.remove('pause-dialog_hidden');

    document.addEventListener('keydown', this._keydownHandler);
  }
  
  _optionsClickHandler = (evt) => {
    if (!evt.target.classList.contains('pause-dialog__toggle')) return;

    this._manageAbilityToToggleHands();
    this._manageAbilityToSubmitOptions();
  };

  _optionsSubmitHandler = (evt) => {
    evt.preventDefault();

    this._submitOptions();
  };

  _overlayClickHandler = () => {
    this._close();
  };
  
  _closeButtonClickHandler = () => {
    this._close();
  };

  _keyboardButtonClickHandler = () => {
    this._openKeyboardSelectDialog();
  };

  _keydownHandler = (evt) => {
    if (evt.key === 'Tab') {
      this._manageFocus(evt);
    }

    if (evt.key === 'Escape') {
      evt.preventDefault();

      this._close();
    }
  };
}

const OS_OPTION = 'os';
const OS_WINDOWS = 'windows';
const OS_MACOS = 'macos';

const ENTER_OPTION = 'enter';
const ENTER_ANSI = 'ansi';
const ENTER_ISO = 'iso';

const LAYOUT_OPTION = 'layout';
const LAYOUT_RUS = 'rus';
const LAYOUT_RUS_PC = 'rus-pc';

const LAYOUTS_NAMES_TRANSLATIONS = new Map ([
  [LAYOUT_RUS, 'Русская'],
  [LAYOUT_RUS_PC, 'Русская-ПК']
]);

const KEYBOARD_TYPE_WINDOWS_ANSI_RUS_PC = 'keyboard-windows-ansi-rus-pc';
const KEYBOARD_TYPE_WINDOWS_ISO_RUS_PC = 'keyboard-windows-iso-rus-pc';
const KEYBOARD_TYPE_MACOS_ANSI_RUS = 'keyboard-macos-ansi-rus';
const KEYBOARD_TYPE_MACOS_ANSI_RUS_PC = 'keyboard-macos-ansi-rus-pc';
const KEYBOARD_TYPE_MACOS_ISO_RUS = 'keyboard-macos-iso-rus';
const KEYBOARD_TYPE_MACOS_ISO_RUS_PC = 'keyboard-macos-iso-rus-pc';

const KEYBOARD_TYPES_TO_OPTION_VARIANTS = new Map ([
  [KEYBOARD_TYPE_WINDOWS_ANSI_RUS_PC, {
    os: OS_WINDOWS,
    enter: ENTER_ANSI
  }],
  [KEYBOARD_TYPE_WINDOWS_ISO_RUS_PC, {
    os: OS_WINDOWS,
    enter: ENTER_ISO
  }],
  [KEYBOARD_TYPE_MACOS_ANSI_RUS, {
    os: OS_MACOS,
    enter: ENTER_ANSI,
    layout: LAYOUT_RUS
  }],
  [KEYBOARD_TYPE_MACOS_ANSI_RUS_PC, {
    os: OS_MACOS,
    enter: ENTER_ANSI,
    layout: LAYOUT_RUS_PC
  }],
  [KEYBOARD_TYPE_MACOS_ISO_RUS, {
    os: OS_MACOS,
    enter: ENTER_ISO,
    layout: LAYOUT_RUS
  }],
  [KEYBOARD_TYPE_MACOS_ISO_RUS_PC, {
    os: OS_MACOS,
    enter: ENTER_ISO,
    layout: LAYOUT_RUS_PC
  }],
]);

class KeyboardSelectDialog {
  constructor (keyboard) {
    this._element = document.querySelector('.keyboard-select-dialog');
    this._overlay = this._element.querySelector('.keyboard-select-dialog__overlay');
    this._options = this._element.querySelector('.keyboard-select-dialog__options');
    this._layoutOption = this._options.querySelector('.keyboard-select-dialog__option_layout');

    this._closeButton = this._element.querySelector('.keyboard-select-dialog__close-button');
    this._submitButton = this._options.querySelector('.keyboard-select-dialog__submit-button');

    this._overlay.addEventListener('click', this._overlayClickHandler);
    this._closeButton.addEventListener('click', this._closeButtonClickHandler);
    this._options.addEventListener('change', this._optionChangeHandler);
    this._options.addEventListener('submit', this._optionSubmitHandler);

    this._keyboard = keyboard;

    // Если тип клавиатуры не определен, то начальные настройки
    // соответствуют самому популярному варианту
    this._initialKeyboardType = this._keyboard.type ?
        this._keyboard.type : KEYBOARD_TYPE_WINDOWS_ANSI_RUS_PC;

    this._isRequired = false;

    this._setInitialOptionVariants();
  }

  open (isRequired) {
    this._isRequired = Boolean(isRequired);

    this._prepareDialogForOpening();

    return new Promise((resolve => {
      this._closeDialogPromiseResolver = resolve;
    }));
  }

  get keyboardLayout () {
    if (this._options[OS_OPTION] === OS_WINDOWS) {
      return LAYOUTS_NAMES_TRANSLATIONS[LAYOUT_RUS_PC];
    }

    return LAYOUTS_NAMES_TRANSLATIONS.get(
      this._options[LAYOUT_OPTION].value
    );
  }

  _prepareDialogForOpening () {
    this._element.classList.remove('keyboard-select-dialog_hidden');

    document.addEventListener('keydown', this._keydownHandler);

    if (this._isRequired) {
      this._closeButton.classList.add('keyboard-select-dialog__close-button_hidden');
      this._submitButton.disabled = false;
    } else {
      this._closeButton.classList.remove('keyboard-select-dialog__close-button_hidden');
    }

    this._getFirstFocusableElement().focus();
  }

  _close () {
    if (this._isRequired) return;

    this._prepareDialogForClosing();

    this._closeDialogPromiseResolver();
  };

  _prepareDialogForClosing () {
    this._element.classList.add('keyboard-select-dialog_hidden');

    document.removeEventListener('keydown', this._keydownHandler);

    this._setInitialOptionVariants();
  }

  _setInitialOptionVariants () {
    const initialOptionVariants = KEYBOARD_TYPES_TO_OPTION_VARIANTS.get(this._initialKeyboardType);

    this._options[OS_OPTION].value = initialOptionVariants.os;
    this._options[ENTER_OPTION].value = initialOptionVariants.enter;
    this._options[LAYOUT_OPTION].value = initialOptionVariants.layout ?
        initialOptionVariants.layout : LAYOUT_RUS;

    this._manageNeedToSelectLayout();
    this._manageAbilityToSubmitOptions();
  }

  _calculateCurrentKeyboardType () {
    const osOptionVariant = this._options[OS_OPTION].value;
    const enterOptionVariant = this._options[ENTER_OPTION].value;
    const layoutOptionVariant = this._options[LAYOUT_OPTION].value;

    if (osOptionVariant === OS_WINDOWS) {
      return enterOptionVariant === ENTER_ANSI ?
          KEYBOARD_TYPE_WINDOWS_ANSI_RUS_PC :
          KEYBOARD_TYPE_WINDOWS_ISO_RUS_PC;
    }

    if (enterOptionVariant === ENTER_ANSI) {
      return layoutOptionVariant === LAYOUT_RUS ?
          KEYBOARD_TYPE_MACOS_ANSI_RUS :
          KEYBOARD_TYPE_MACOS_ANSI_RUS_PC;
    } else {
      return layoutOptionVariant === LAYOUT_RUS ?
          KEYBOARD_TYPE_MACOS_ISO_RUS :
          KEYBOARD_TYPE_MACOS_ISO_RUS_PC;
    }
  }

  _submitOptions () {
    this._initialKeyboardType = this._calculateCurrentKeyboardType();
    this._keyboard.changeType(this._initialKeyboardType);

    this._submitButton.disabled = true;

    if (!this._isRequired) return;

    // Обязательная форма закрывается только при сабмите
    this._isRequired = false;
    this._close();
  }

  _manageAbilityToSubmitOptions () {
    if (this._isRequired) return;

    this._submitButton.disabled = this._initialKeyboardType === this._calculateCurrentKeyboardType();
  }

  _manageNeedToSelectLayout () {
    if (this._options[OS_OPTION].value === OS_MACOS) {
      this._layoutOption.classList.remove('keyboard-select-dialog__option_hidden');
    } else {
      this._layoutOption.classList.add('keyboard-select-dialog__option_hidden');
    }
  }

  _manageFocus (evt) {
    const firstFocusableElement = this._getFirstFocusableElement();
    const lastFocusableElement = this._getLastFocusableElement();

    if (evt.shiftKey) {
      if (document.activeElement === firstFocusableElement) {
        evt.preventDefault();
        lastFocusableElement.focus();
      }
    } else if (document.activeElement === lastFocusableElement) {
      evt.preventDefault();
      firstFocusableElement.focus();
    }
  }
  
  _getFirstFocusableElement () {
    return this._closeButton.classList.contains('keyboard-select-dialog__close-button_hidden') ?
      this._options.querySelector('.keyboard-select-dialog__option_os :checked') :
      this._closeButton;
  }

  _getLastFocusableElement () {
    if (!this._submitButton.disabled) {
      return this._submitButton;
    }

    return this._layoutOption.classList.contains('keyboard-select-dialog__option_hidden') ?
        this._options.querySelector('.keyboard-select-dialog__option_enter :checked') :
        this._options.querySelector('.keyboard-select-dialog__option_layout :checked');
  }

  _optionChangeHandler = () => {
    this._manageNeedToSelectLayout();
    this._manageAbilityToSubmitOptions();
  };

  _optionSubmitHandler = (evt) => {
    evt.preventDefault();

    this._submitOptions();
  };

  _overlayClickHandler = () => {
    this._close();
  };

  _closeButtonClickHandler = () => {
    this._close();
  };

  _keydownHandler = (evt) => {
    if (evt.key === 'Tab') {
      this._manageFocus(evt);
    }

    if (evt.key === 'Escape') {
      evt.preventDefault();

      this._close();
    }
  };
}

class Button {
  constructor (element, clickHandler) {
    this._element = element;
    element.addEventListener("click", clickHandler);
  }

  focus () {
    this._element.focus();
  }

  get isFocused () {
    return document.activeElement === this._element;
  }
}

class Toggle {
  constructor (element) {
    this._element = element;
    this._element.addEventListener('click', this._clickHandler);
  }
  
  toggle () {
    if (this._element.getAttribute('aria-checked') === 'true') {
      this._element.setAttribute('aria-checked', 'false');
    } else {
      this._element.setAttribute('aria-checked', 'true');
    }
  }

  get element () {
    return this._element;
  }

  get isChecked () {
    return this._element.getAttribute('aria-checked') === 'true';
  }

  set disabled (isDisabled) {
    this._element.disabled = isDisabled;
  }

  _clickHandler = () => {
    this.toggle();
  };
}

const SERIES_MAX_LENGTH = 3;

class Statistics {
  constructor(problemKeyCodes) {
    this._problemKeyCodes = new Set(problemKeyCodes);

    this._seriesCounters = new Map();
    this._currentSeries = new Map();

    this._typoCounters = new Map();
  }

  addWrongKeyCode(keyCode) {
    let typoCounter = (this._typoCounters.has(keyCode)) ?
      this._typoCounters.get(keyCode) : 0;

    typoCounter++;

    this._typoCounters.set(keyCode, typoCounter);

    if (this._currentSeries.has(keyCode)) {
      this._currentSeries.set(keyCode, 0);
    }
  }

  addCorrectKeyCode(keyCode) {
    if (!this._problemKeyCodes.has(keyCode)) return;

    let currentSeries = (this._currentSeries.has(keyCode)) ?
      this._currentSeries.get(keyCode) : 0;

    currentSeries++;

    if (currentSeries < SERIES_MAX_LENGTH) {
      this._currentSeries.set(keyCode, currentSeries);
      return;
    }

    this._currentSeries.set(keyCode, 0);

    let seriesCounter = (this._seriesCounters.has(keyCode)) ?
      this._seriesCounters.get(keyCode) : 0;

    seriesCounter++;

    this._seriesCounters.set(keyCode, seriesCounter);
  }

  get keyCodesToTypoAmounts () {
    return this._typoCounters;
  }

  get keyCodesToCorrectSeriesAmounts () {
    return this._seriesCounters;
  }
}


const simulator = new Simulator({
  hintDialogMessage: 'Добро пожаловать в тренажер слепой печати!',
  textBoxTexts: [
    'Добро пожаловать в тренажер слепой печати!',
    'Тренируйся каждый день по 15 минут',
    'И совсем скоро ты будешь печатать, обгоняя мысли'
  ],
  keyboardType: '',
  areHandsOn: true,
  isKeyboardOn: true,
  problemKeyCodes: []
});

//# sourceMappingURL=script.min.js.map
